package com.mutisitc.statement;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;

import com.mutisitc.utils.CommonUtil;
import com.mutisitc.utils.JDBCUtil;
import com.mutisitc.utils.PrintUtil;

/**
 * @program java.sql.Statement：基本语句
 * @description
 * @author mutisitic
 * @date 2018年9月21日
 */
public class StatementMain {
	public static void main(String[] args) {
		PrintUtil.one("java.sql.Statement：基本语句：");
		try {
			Statement statement = JDBCUtil.createStatement();

			String insertSQL = testInsertSQL(System.currentTimeMillis());
			statement.addBatch(insertSQL);
			PrintUtil.two("3.Statement.addBatch(String sql)：将给定的SQL命令添加到此Statement对象的当前命令列表中", "insertSQL=" + insertSQL);

			statement.cancel();
			PrintUtil.two("4.Statement.cancel()", "Statement如果DBMS和驱动程序都支持中止SQL语句，则取消此对象");

			statement.clearBatch();
			PrintUtil.two("5.Statement.clearBatch()", "清空此Statement对象的当前SQL命令列表");

			statement.clearWarnings();
			PrintUtil.two("6.Statement.clearWarnings()", "清除此Statement对象上报告的所有警告");

			boolean executeResult = statement.execute(insertSQL);
			PrintUtil.two("7.Statement.execute(String sql)：执行给定的SQL语句，该语句可能返回多个结果", "executeResult=" + executeResult + ",insertSQL=" + insertSQL);

			insertSQL = testInsertSQL(System.currentTimeMillis());
			boolean executeResult2 = statement.execute(insertSQL, Statement.RETURN_GENERATED_KEYS);
			PrintUtil.two("8.Statement.execute(String sql, int autoGeneratedKeys)：执行给定的SQL语句（该语句可能返回多个结果），并通知驱动程序所有自动生成的键都应该可用于获取",
					"autoGeneratedKeys=Statement.RETURN_GENERATED_KEYS=" + Statement.RETURN_GENERATED_KEYS + ", executeResult=" + executeResult2 + ",insertSQL=" + insertSQL);

			insertSQL = testInsertSQL(System.currentTimeMillis());
			boolean executeResult3 = statement.execute(insertSQL, new int[] { 0 });
			PrintUtil.two("9.Statement.execute(String sql, int[] columnIndexes)：执行给定的SQL语句（该语句可能返回多个结果），并通知驱动程序在给定数组中指示的自动生成的键应该可用于获取。此数组包含目标表中的列的索引，而该目标表包含应该使其可用的自动生成的键",
					"columnIndexes=new int[] {0}" + ", executeResult=" + executeResult3 + ",insertSQL=" + insertSQL);

			insertSQL = testInsertSQL(System.currentTimeMillis());
			boolean executeResult4 = statement.execute(insertSQL, new String[] { "bookId" });
			PrintUtil.two("10.Statement.execute(String sql, String[] columnNames)：执行给定的SQL语句（该语句可能返回多个结果），并通知驱动程序在给定数组中指示的自动生成的键应该可用于获取。此数组包含目标表中的列的名称，而该目标表包含应该使其可用的自动生成的键",
					"columnIndexes=new String[] { \"bookId\" }" + ", executeResult=" + executeResult4 + ",insertSQL=" + insertSQL);

			statement.addBatch(testInsertSQL(System.currentTimeMillis() + 1));
			statement.addBatch(testInsertSQL(System.currentTimeMillis() + 2));
			int[] executeBatchResult = statement.executeBatch();
			PrintUtil.two("11.Statement.executeBatch()：将一批命令提交到数据库以供执行，如果所有命令成功执行，则返回一组更新计数", "executeBatchResult=" + CommonUtil.toString(executeBatchResult));

			insertSQL = testInsertSQL(System.currentTimeMillis());
			long executeLargeUpdate = statement.executeLargeUpdate(insertSQL);
			PrintUtil.two("12.Statement.executeLargeUpdate(String sql)：执行给定的SQL语句，它可以是一个INSERT， UPDATE或者DELETE语句，或者不返回任何内容的SQL语句(如SQL DDL语句)",
					"executeLargeUpdate=" + executeLargeUpdate + ",insertSQL=" + insertSQL);

			insertSQL = testInsertSQL(System.currentTimeMillis());
			long executeLargeUpdate2 = statement.executeLargeUpdate(insertSQL, Statement.RETURN_GENERATED_KEYS);
			PrintUtil.two("13.Statement.executeLargeUpdate(String sql, int autoGeneratedKeys)：执行给定的SQL语句，并通知驱动程序所有自动生成的键都应该可用于获取",
					"autoGeneratedKeys=Statement.RETURN_GENERATED_KEYS=" + Statement.RETURN_GENERATED_KEYS + ", executeLargeUpdate=" + executeLargeUpdate2 + ",insertSQL=" + insertSQL);

			insertSQL = testInsertSQL(System.currentTimeMillis());
			long executeLargeUpdate3 = statement.executeLargeUpdate(insertSQL, new int[] { 0 });
			PrintUtil.two("14.Statement.executeLargeUpdate(String sql, int[] columnIndexes)：执行给定的SQL语句，并通知驱动程序在给定数组中指示的自动生成的键应该可用于获取。此数组包含目标表中的列的索引，而该目标表包含应该使其可用的自动生成的键",
					"columnIndexes=new int[] {0}" + ", executeLargeUpdate=" + executeLargeUpdate3 + ",insertSQL=" + insertSQL);

			insertSQL = testInsertSQL(System.currentTimeMillis());
			long executeLargeUpdate4 = statement.executeLargeUpdate(insertSQL, new String[] { "bookId" });
			PrintUtil.two("15.Statement.executeLargeUpdate(String sql, String[] columnNames)：执行给定的SQL语句，并通知驱动程序在给定数组中指示的自动生成的键应该可用于获取。此数组包含目标表中的列的名称，而该目标表包含应该使其可用的自动生成的键",
					"columnIndexes=new String[] { \"bookId\" }" + ", executeLargeUpdate=" + executeLargeUpdate4 + ",insertSQL=" + insertSQL);

			String querySQL = "SELECT bookId, title, author, remark, createrTime FROM book";
			ResultSet resultSet = statement.executeQuery(querySQL);
			PrintUtil.two("16.Statement.executeQuery(String sql)：执行给定的SQL语句，该语句返回单个 ResultSet对象", "ResultSet=" + resultSet + ", querySQL=" + querySQL);

			insertSQL = testInsertSQL(System.currentTimeMillis());
			long executeUpdate = statement.executeUpdate(insertSQL);
			PrintUtil.two("17.Statement.executeUpdate(String sql)：执行给定的SQL语句，它可以是一个INSERT， UPDATE或者DELETE语句，或者不返回任何内容的SQL语句(如SQL DDL语句)",
					"executeUpdate=" + executeUpdate + ",insertSQL=" + insertSQL);

			insertSQL = testInsertSQL(System.currentTimeMillis());
			long executeUpdate2 = statement.executeUpdate(insertSQL, Statement.RETURN_GENERATED_KEYS);
			PrintUtil.two("18.Statement.executeUpdate(String sql, int autoGeneratedKeys)：执行给定的SQL语句，并通知驱动程序所有自动生成的键都应该可用于获取",
					"autoGeneratedKeys=Statement.RETURN_GENERATED_KEYS=" + Statement.RETURN_GENERATED_KEYS
							+ ", executeUpdate=" + executeUpdate2 + ",insertSQL=" + insertSQL);

			insertSQL = testInsertSQL(System.currentTimeMillis());
			long executeUpdate3 = statement.executeUpdate(insertSQL, new int[] { 0 });
			PrintUtil.two("19.Statement.executeUpdate(String sql, int[] columnIndexes)：执行给定的SQL语句，并通知驱动程序在给定数组中指示的自动生成的键应该可用于获取。此数组包含目标表中的列的索引，而该目标表包含应该使其可用的自动生成的键",
					"columnIndexes=new int[] {0}" + ", executeUpdate=" + executeUpdate3 + ",insertSQL=" + insertSQL);

			insertSQL = testInsertSQL(System.currentTimeMillis());
			long executeUpdate4 = statement.executeUpdate(insertSQL, new String[] { "bookId" });
			PrintUtil.two("20.Statement.executeUpdate(String sql, String[] columnNames)：执行给定的SQL语句，并通知驱动程序在给定数组中指示的自动生成的键应该可用于获取。此数组包含目标表中的列的名称，而该目标表包含应该使其可用的自动生成的键",
					"columnIndexes=new String[] { \"bookId\" }" + ", executeUpdate=" + executeUpdate4 + ",insertSQL=" + insertSQL);

			Connection connection = statement.getConnection();
			PrintUtil.two("21.Statement.getConnection()：检索Connection生成此Statement对象的对象", "Connection=" + connection);

			int fetchDirection = statement.getFetchDirection();
			PrintUtil.two("22.Statement.getFetchDirection()：检索从数据库表中获取行的方向，该方向是从此Statement对象生成的结果集的缺省值", "fetchDirection=" + fetchDirection);

			int fetchSize = statement.getFetchSize();
			PrintUtil.two("23.Statement.getFetchDirection()：检索结果集行的数量，该行是ResultSet从此对象生成的对象的默认提取大小Statement", "fetchSize=" + fetchSize);

			ResultSet generatedKeys = statement.getGeneratedKeys();
			PrintUtil.two("24.Statement.getGeneratedKeys()：检索由于执行此Statement对象而创建的任何自动生成的密钥", "generatedKeys=" + generatedKeys);

			long largeMaxRows = statement.getLargeMaxRows();
			PrintUtil.two("25.Statement.getLargeMaxRows()：检索此ResultSet对象生成的 Statement对象可以包含的最大行数", "largeMaxRows=" + largeMaxRows);

			long largeUpdateCount = statement.getLargeUpdateCount();
			PrintUtil.two("26.Statement.getLargeUpdateCount()：检索当前结果作为更新计数; 如果结果是ResultSet对象或没有更多结果，则返回-1", "largeUpdateCount=" + largeUpdateCount);

			long maxFieldSize = statement.getMaxFieldSize();
			PrintUtil.two("27.Statement.getMaxFieldSize()：检索此ResultSet 对象生成的Statement对象中的字符和二进制列值可以返回的最大字节数1", "maxFieldSize=" + maxFieldSize);

			statement.setMaxFieldSize(4);
			PrintUtil.two("28.Statement.setMaxFieldSize(int max)：设置此ResultSet 对象生成的Statement对象中字符和二进制列值可返回的最大字节数限制", "maxFieldSize=3");

			long maxRows = statement.getMaxRows();
			PrintUtil.two("29.Statement.getMaxRows()：检索此ResultSet对象生成的 Statement对象可以包含的最大行数", "maxRows=" + maxRows);

			statement.setMaxRows(3);
			PrintUtil.two("30.Statement.setMaxRows(int max)：设置此ResultSet 对象生成的Statement对象中字符和二进制列值可返回的最大字节数限制", "maxRows=3");

			boolean moreResults = statement.getMoreResults();
			PrintUtil.two("31.Statement.getMoreResults()：移动到此Statement对象的下一个结果，true如果它是ResultSet对象则返回 ，并隐式关闭ResultSet 使用该方法获得的任何当前对象getResultSet", "moreResults=" + moreResults);

			boolean moreResults2 = statement.getMoreResults(0);
			PrintUtil.two("32.Statement.getMoreResults(int current)：移动到此Statement对象的下一个结果，ResultSet根据给定标志指定的指令处理任何当前对象，并true在下一个结果是ResultSet对象时返回", "moreResults=" + moreResults2);

			int queryTimeout = statement.getQueryTimeout();
			PrintUtil.two("33.Statement.getQueryTimeout()：检索驱动程序等待Statement对象执行的秒数", "queryTimeout=" + queryTimeout);

			queryTimeout = 10;
			statement.setQueryTimeout(queryTimeout);
			PrintUtil.two("34.Statement.setQueryTimeout(int seconds)：将驱动程序等待 Statement对象执行的秒数设置为给定的秒数", "queryTimeout=" + queryTimeout);

			ResultSet resultSet2 = statement.getResultSet();
			PrintUtil.two("35.Statement.getQueryTimeout()：检索驱动程序等待Statement对象执行的秒数", "ResultSet=" + resultSet2);

			int resultSetConcurrency = statement.getResultSetConcurrency();
			PrintUtil.two("36.Statement.getResultSetConcurrency()：检索此ResultSet对象生成的Statement对象的结果集并发性", "resultSetConcurrency=" + resultSetConcurrency);

			int resultSetHoldability = statement.getResultSetHoldability();
			PrintUtil.two("37.Statement.getResultSetHoldability()：检索此ResultSet对象生成的Statement对象的结果集可保持性", "resultSetHoldability=" + resultSetHoldability);

			int resultSetType = statement.getResultSetType();
			PrintUtil.two("38.Statement.getResultSetType()：检索此ResultSet对象生成的Statement对象的结果集类型", "resultSetType=" + resultSetType);

			int updateCount = statement.getUpdateCount();
			PrintUtil.two("39.Statement.getUpdateCount()：检索当前结果作为更新计数; 如果结果是ResultSet对象或没有更多结果，则返回-1", "updateCount=" + updateCount);

			SQLWarning sqlWarning = statement.getWarnings();
			PrintUtil.two("40.Statement.getWarnings()：检索此Statement对象上的调用报告的第一个警告", "SQLWarning=" + sqlWarning);

			boolean isClosed = statement.isClosed();
			PrintUtil.two("41.Statement.isClosed()：检索此Statement对象是否已关闭", "isClosed=" + isClosed);

			boolean isCloseOnCompletion = statement.isCloseOnCompletion();
			PrintUtil.two("42.Statement.isCloseOnCompletion()：返回一个值，该值指示Statement在关闭所有相关结果集时是否将关闭此值", "isCloseOnCompletion=" + isCloseOnCompletion);

			boolean isPoolable = statement.isPoolable();
			PrintUtil.two("43.Statement.isPoolable()：返回一个值，指示是否Statement 可以使用poolable", "isPoolable=" + isPoolable);

			isPoolable = false;
			statement.setPoolable(isPoolable);
			PrintUtil.two("44.Statement.setPoolable(boolean poolable)：请求将 Statement 池化或非池化", "poolable=false");

			statement.setCursorName("test");
			PrintUtil.two("45.Statement.setCursorName(String name)：将SQL游标名称设置为给定的String，后续Statement对象 execute方法将使用该名称", "cursorName=test");

			statement.setEscapeProcessing(true);
			PrintUtil.two("46.Statement.setEscapeProcessing(boolean enable)：打开或关闭转义处理", "enable=true");
			
			statement.setFetchDirection(ResultSet.FETCH_FORWARD);
			PrintUtil.two("47.Statement.setFetchDirection(int direction)：为驱动程序提供有关ResultSet在使用此Statement对象创建的对象中处理行的方向的提示", "direction=ResultSet.FETCH_FORWARD="+ResultSet.FETCH_FORWARD);
			
			statement.setFetchSize(3);
			PrintUtil.two("48.Statement.setFetchSize(int rows)：为JDBC驱动程序提供有关当ResultSet由此生成的对象需要更多行时应从数据库获取的行数的提示Statement", "rows=3");
			
			statement.setLargeMaxRows(3);
			PrintUtil.two("49.Statement.setLargeMaxRows(int max)：ResultSet将此Statement对象生成的任何对象可包含的最大行数限制设置为给定数字", "largeMaxRows=3");

			statement.closeOnCompletion();
			PrintUtil.two("50.Statement.closeOnCompletion()：", "指定Statement在关闭所有相关结果集时将关闭它");
			
			statement.close();
			PrintUtil.two("51.Statement.close()：", "立即释放此Statement对象的数据库和JDBC资源，而不是等待它自动关闭时发生");
		} catch (SQLException e) {
			PrintUtil.err("演示 java.sql.Statement：基本语句，打印异常堆栈信息：");
			e.printStackTrace();
		}
	}

	/**
	 * @description 测试insert sql语句
	 * @author mutisitic
	 * @date 2018年9月25日
	 * @param bookId
	 *            主键
	 * @return insert sql
	 */
	private static String testInsertSQL(Long bookId) {
		return "INSERT INTO `book` (`bookId`, `title`, `author`, `remark`, `createrTime`) VALUES (" + bookId
				+ ", 'test by jdbc', 'test author', 'test remark', '" + CommonUtil.getCurrentTime() + "')";
	}

}
