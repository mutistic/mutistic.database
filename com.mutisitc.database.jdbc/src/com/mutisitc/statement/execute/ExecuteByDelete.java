package com.mutisitc.statement.execute;

import java.sql.SQLException;
import java.sql.Statement;

import com.mutisitc.utils.PrintUtil;

/**
 * @program 使用Statement.execute接口实现数据删除
 * @description
 * @author mutisitic
 * @date 2018年9月25日
 */
public class ExecuteByDelete {
	/**
	 * @description 使用Statement.execute接口实现数据删除
	 * @author mutisitic
	 * @date 2018年9月26日
	 * @param statement
	 * @throws SQLException
	 */
	public static void mainByDelete(Statement statement) throws SQLException {
		PrintUtil.one("一、使用 Statement.execute(String sql)：数据删除：");
		
		String deleteSQL = testSQL(1537930111701L);
		PrintUtil.two("3.数据删除SQL语句：", deleteSQL);

		boolean executeResult = statement.execute(deleteSQL);
		PrintUtil.two("4.Statement.execute(String sql)：数据删除执行结果", "executeResult=" + executeResult);
		PrintUtil.three("4.1：具体描述:", "执行给定的 SQL 语句，该语句可能返回多个结果。在某些（不常见）情形下，单个 SQL 语句可能返回多个结果集合和/或更新计数。"
				+ "  \n 这一点通常可以忽略，除非正在 执行已知可能返回多个结果的存储过程或者动态执行未知 SQL 字符串。  execute 方法执行 SQL 语句并指示第一个结果的形式。"
				+ "  \n 然后，必须使用方法 getResultSet 或 getUpdateCount 来获取结果，使用 getMoreResults 来移动后续结果");
		PrintUtil.three("4.2：方法返回结果：", "如果第一个结果为 ResultSet 对象，则返回 true；如果其为更新计数或者不存在任何结果，则返回 false");
		PrintUtil.three("4.3：方法参数说明：", "参数autoGeneratedKeys、columnIndexes、columnNames在非insert语句时，将会被忽略，具体源码分析：\n"
				+ "com.mysql.cj.jdbc.StatementImpl.executeInternal(String sql, boolean returnGeneratedKeys)：方法具体代码段：\n"
				+ "this.lastQueryIsOnDupKeyUpdate = returnGeneratedKeys && firstNonWsChar == 'I' && containsOnDuplicateKeyInString(sql);");
		
		PrintUtil.two("5.使用Statement.getResultSet()获取执行SQL后的结果", "java.sql.ResultSet=" + statement.getResultSet());
		PrintUtil.two("6.使用Statement.getUpdateCount()获取执行SQL后的结果", "updateCount=" + statement.getUpdateCount());
	}

	/**
	 * @description 测试删除SQL
	 * @author mutisitic
	 * @date 2018年9月26日
	 * @param bookId 主键ID
	 * @return
	 */
	private static String testSQL(Long bookId) {
		return "DELETE FROM book WHERE bookId = "+ bookId;
	}
}
