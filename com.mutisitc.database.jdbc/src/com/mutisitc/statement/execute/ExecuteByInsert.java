package com.mutisitc.statement.execute;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import com.mutisitc.utils.CommonUtil;
import com.mutisitc.utils.PrintUtil;

/**
 * @program 使用Statement.execute接口实现数据新增
 * @description
 * @author mutisitic
 * @date 2018年9月25日
 */
public class ExecuteByInsert {
	/**
	 * @description 使用Statement.execute接口实现数据新增
	 * @author mutisitic
	 * @date 2018年9月26日
	 * @param statement
	 * @throws SQLException
	 */
	public static void mainByInsert(Statement statement) throws SQLException {
		mianByExecute(statement);
		mianByAutoGeneratedKeys(statement);
		mainByColumnIndexes(statement);
		mainByColumnNames(statement);
		
		PrintUtil.two("\n五、根据mysql-connector-java-8.0.11.jar源码分析",
				"参数autoGeneratedKeys、columnIndexes、columnNames，都是执行insert操作时，用于并通知驱动程序在给定数组中指示的自动生成的键应该可用于获取，后续获取自动生成的键步骤基本一致，此外并没有其他的不同：\n"
				+ "com.mysql.cj.jdbc.StatementImpl：方法具体代码：\n"
				+ "public boolean execute(String sql, int returnGeneratedKeys) throws SQLException {\r\n"
				+ "   return executeInternal(sql, returnGeneratedKeys == java.sql.Statement.RETURN_GENERATED_KEYS);\r\n"
				+ "}\r\n"
				+ "public boolean execute(String sql, int[] generatedKeyIndices) throws SQLException {\r\n"
				+ "   return executeInternal(sql, generatedKeyIndices != null && generatedKeyIndices.length > 0);\r\n"
				+ "}\r\npublic boolean execute(String sql, String[] generatedKeyNames) throws SQLException {\r\n"
				+ "   return executeInternal(sql, generatedKeyNames != null && generatedKeyNames.length > 0);\r\n"
				+ "}");
	}

	/**
	 * @description 使用 Statement.execute(String sql)：数据新增
	 * @author mutisitic
	 * @date 2018年9月25日
	 * @param statement
	 * @throws SQLException
	 */
	private static void mianByExecute(Statement statement) throws SQLException {
		PrintUtil.one("一、使用 Statement.execute(String sql)：数据新增：");
		
		String insertSQL = testSQL(System.currentTimeMillis());
		PrintUtil.two("3.数据新增SQL语句：", insertSQL);

		boolean executeResult = statement.execute(insertSQL);
		PrintUtil.two("4.Statement.execute(String sql)：数据新增执行结果", "executeResult=" + executeResult);
		PrintUtil.three("4.1：具体描述:", "执行给定的 SQL 语句，该语句可能返回多个结果。在某些（不常见）情形下，单个 SQL 语句可能返回多个结果集合和/或更新计数。"
				+ "  \n 这一点通常可以忽略，除非正在 执行已知可能返回多个结果的存储过程或者动态执行未知 SQL 字符串。  execute 方法执行 SQL 语句并指示第一个结果的形式。"
				+ "  \n 然后，必须使用方法 getResultSet 或 getUpdateCount 来获取结果，使用 getMoreResults 来移动后续结果");
		PrintUtil.three("4.2：方法返回结果：", "如果第一个结果为 ResultSet 对象，则返回 true；如果其为更新计数或者不存在任何结果，则返回 false");

		PrintUtil.two("5.使用Statement.getResultSet()获取执行SQL后的结果", "java.sql.ResultSet=" + statement.getResultSet());
		PrintUtil.two("6.使用Statement.getUpdateCount()获取执行SQL后的结果", "updateCount=" + statement.getUpdateCount());
	}
	
	/**
	 * @description 使用  Statement.execute(String sql, int autoGeneratedKeys)：数据新增
	 * @author mutisitic
	 * @date 2018年9月25日
	 * @param statement
	 * @throws SQLException
	 */
	private static void mianByAutoGeneratedKeys(Statement statement) throws SQLException {
		PrintUtil.one("二、使用  Statement.execute(String sql, int autoGeneratedKeys)：数据新增：");
		
		String insertSQL = testSQL(null);
		PrintUtil.two("3.数据新增SQL语句：", insertSQL);

		boolean executeResult = statement.execute(insertSQL, Statement.RETURN_GENERATED_KEYS);
		PrintUtil.two("4.Statement.execute(String sql, int autoGeneratedKeys)：数据新增执行结果", "executeResult=" + executeResult);
		PrintUtil.three("4.1：具体描述:", "执行给定的 SQL 语句（该语句可能返回多个结果），并通知驱动程序所有自动生成的键都应该可用于获取。\n"
				+ "如果该 SQL 语句不是 INSERT 语句，或者不是可以返回自动生成键的 SQL 语句（这些语句的列表是特定于供应商的），则驱动程序将忽略此信号。\n" + 
				"在某些（不常见）情形下，单个 SQL 语句可能返回多个结果集合和/或更新计数。这一点通常可以忽略，除非正在 执行已知可能返回多个结果的存储过程或者 动态执行未知 SQL 字符串。 " + 
				"execute 方法执行 SQL 语句并指示第一个结果的形式。然后，必须使用方法 getResultSet 或 getUpdateCount 来获取结果，使用 getMoreResults 来移动后续结果");
		PrintUtil.three("4.2：参数描述：autoGeneratedKeys", "指示是否应该使用 getGeneratedKeys 方法使自动生成的键可用于获取的常量；"
				+ "  \n 以下常量之一：Statement.RETURN_GENERATED_KEYS 或 Statement.NO_GENERATED_KEYS ");
		PrintUtil.three("4.3：方法返回结果：", "如果第一个结果为 ResultSet 对象，则返回 true；如果其为更新计数或者不存在任何结果，则返回 false");

		PrintUtil.two("5.使用Statement.getResultSet()获取执行SQL后的结果", "java.sql.ResultSet=" + statement.getResultSet());
		PrintUtil.two("6.使用Statement.getUpdateCount()获取执行SQL后的结果", "updateCount=" + statement.getUpdateCount());
		
		ResultSet generatedKeys = statement.getGeneratedKeys();
		PrintUtil.two("7.当指定参数autoGeneratedKeys时，且autoGeneratedKeys=Statement.RETURN_GENERATED_KEYS"+Statement.RETURN_GENERATED_KEYS, 
				"可以使用Statement.sgetGeneratedKeys()获取由于执行此 Statement对象而创建的所有自动生成的键(可能执行多个insert sql)");
		PrintUtil.three("7.1：当参数指autoGeneratedKeys定为Statement.NO_GENERATED_KEYS或不为Statement.RETURN_GENERATED_KEYS的其他值",
				"则不能调用Statement.sgetGeneratedKeys()，否者会抛出异常：\n"
				+ "异常信息为：java.sql.SQLException: Generated keys not requested. You need to specify Statement.RETURN_GENERATED_KEYS to Statement.executeUpdate(), Statement.executeLargeUpdate() or Connection.prepareStatement().");
		PrintUtil.three("7.2：由于可能执行多个insert sql：", "所以使用ResultSet作为接受自动生成主键的集合，通过循环获取每个执行结果的主键，获取索引从1开始");
		PrintUtil.three("7.3：如果表主键没有设置为自增主键的情况下", "是要在insert 指定每条数据的主键ID，且不重复，故不需要通过Statement.sgetGeneratedKeys()再次获取主键，当然获取的主键的集合也insert 数据记录的集合主键一致");
		PrintUtil.three("7.4：通过ResultSet.getXXX(1)获取主键", "注意要和表主键的数据类型映射到java数据一致");
		if(generatedKeys != null) {
			while (generatedKeys.next()) {
				PrintUtil.three("7.5.通过循环获取到的执行结果后的主键ID", "bookId="+generatedKeys.getLong(1));
			}
		}
	}
	
	/**
	 * @description 使用  Statement.execute(String sql, int[] columnIndexes)：数据新增
	 * @author mutisitic
	 * @date 2018年9月25日
	 * @param statement
	 * @throws SQLException 
	 */
	private static void mainByColumnIndexes(Statement statement) throws SQLException {
		PrintUtil.one("三、使用  Statement.execute(String sql, int[] columnIndexes)：数据新增：");
		
		String insertSQL = testSQL(null);
		PrintUtil.two("3.数据新增SQL语句：", insertSQL);

		int[] columnIndexes = new int[] {0};
		boolean executeResult = statement.execute(insertSQL, columnIndexes);
		PrintUtil.two("4.Statement.execute(String sql, int[] columnIndexes)：数据新增执行结果", "executeResult=" + executeResult+", columnIndexes="+ CommonUtil.toString(columnIndexes));
		PrintUtil.three("4.1：具体描述:", "执行给定的 SQL 语句（该语句可能返回多个结果），并通知驱动程序所有自动生成的键都应该可用于获取。\n"
				+ "如果该 SQL 语句不是 INSERT 语句，或者不是可以返回自动生成键的 SQL 语句（这些语句的列表是特定于供应商的），则驱动程序将忽略此信号。\n" + 
				"在某些（不常见）情形下，单个 SQL 语句可能返回多个结果集合和/或更新计数。这一点通常可以忽略，除非正在 执行已知可能返回多个结果的存储过程或者 动态执行未知 SQL 字符串。 " + 
				"execute 方法执行 SQL 语句并指示第一个结果的形式。然后，必须使用方法 getResultSet 或 getUpdateCount 来获取结果，使用 getMoreResults 来移动后续结果");
		PrintUtil.three("4.2：参数描述：columnIndexes", "通过调用方法 getGeneratedKeys 应该可用于获取的插入行中的列索引数组");
		PrintUtil.three("4.3：方法返回结果：", "如果第一个结果为 ResultSet 对象，则返回 true；如果其为更新计数或者不存在任何结果，则返回 false");

		PrintUtil.two("5.使用Statement.getResultSet()获取执行SQL后的结果", "java.sql.ResultSet=" + statement.getResultSet());
		PrintUtil.two("6.使用Statement.getUpdateCount()获取执行SQL后的结果", "updateCount=" + statement.getUpdateCount());
		
		ResultSet generatedKeys = statement.getGeneratedKeys();
		PrintUtil.two("7.当指定参数columnIndexes时，且columnIndexes不为null且空数组时，", 
				"可以使用Statement.sgetGeneratedKeys()获取由于执行此 Statement对象而创建的所有自动生成的键(可能执行多个insert sql)");
		PrintUtil.three("7.1：当参数指columnIndexes定为null或空数组", "则不能调用Statement.sgetGeneratedKeys()，否者会抛出异常：\n"
				+ "异常信息为：java.sql.SQLException: Generated keys not requested. You need to specify Statement.RETURN_GENERATED_KEYS to Statement.executeUpdate(), Statement.executeLargeUpdate() or Connection.prepareStatement().");
		PrintUtil.three("7.2：由于可能执行多个insert sql：", "所以使用ResultSet作为接受自动生成主键的集合，通过循环获取每个执行结果的主键，获取索引从1开始");
		PrintUtil.three("7.3：如果表主键没有设置为自增主键的情况下", "是要在insert 指定每条数据的主键ID，且不重复，故不需要通过Statement.sgetGeneratedKeys()再次获取主键，当然获取的主键的集合也insert 数据记录的集合主键一致");
		PrintUtil.three("7.4：通过ResultSet.getXXX(1)获取主键", "注意要和表主键的数据类型映射到java数据一致");
		if(generatedKeys != null) {
			while (generatedKeys.next()) {
				PrintUtil.three("7.5.通过循环获取到的执行结果后的主键ID", "bookId="+generatedKeys.getLong(1));
			}
		}
	}
	
	/**
	 * @description 使用  Statement.execute(String sql, String[] columnNames)：数据新增
	 * @author mutisitic
	 * @date 2018年9月25日
	 * @param statement
	 * @throws SQLException 
	 */
	private static void mainByColumnNames(Statement statement) throws SQLException {
		PrintUtil.one("四、使用  Statement.execute(String sql, String[] columnNames)：数据新增：");
		
		String insertSQL = testSQL(null);
		PrintUtil.two("3.数据新增SQL语句：", insertSQL);

		String[] columnNames = new String[] {"bookId"};
		boolean executeResult = statement.execute(insertSQL, columnNames);
		PrintUtil.two("4.Statement.execute(String sql, int[] columnIndexes)：数据新增执行结果", "executeResult=" + executeResult+", columnNames="+ CommonUtil.toString(columnNames));
		PrintUtil.three("4.1：具体描述:", "执行给定的 SQL 语句（该语句可能返回多个结果），并通知驱动程序所有自动生成的键都应该可用于获取。\n"
				+ "如果该 SQL 语句不是 INSERT 语句，或者不是可以返回自动生成键的 SQL 语句（这些语句的列表是特定于供应商的），则驱动程序将忽略此信号。\n" + 
				"在某些（不常见）情形下，单个 SQL 语句可能返回多个结果集合和/或更新计数。这一点通常可以忽略，除非正在 执行已知可能返回多个结果的存储过程或者 动态执行未知 SQL 字符串。 " + 
				"execute 方法执行 SQL 语句并指示第一个结果的形式。然后，必须使用方法 getResultSet 或 getUpdateCount 来获取结果，使用 getMoreResults 来移动后续结果");
		PrintUtil.three("4.2：参数描述：columnNames", "通过调用方法 getGeneratedKeys 应该可用于获取的插入行中的列名称数组");
		PrintUtil.three("4.3：方法返回结果：", "如果第一个结果为 ResultSet 对象，则返回 true；如果其为更新计数或者不存在任何结果，则返回 false");

		PrintUtil.two("5.使用Statement.getResultSet()获取执行SQL后的结果", "java.sql.ResultSet=" + statement.getResultSet());
		PrintUtil.two("6.使用Statement.getUpdateCount()获取执行SQL后的结果", "updateCount=" + statement.getUpdateCount());
		
		ResultSet generatedKeys = statement.getGeneratedKeys();
		PrintUtil.two("7.当指定参数columnNames时，且columnNames不为null且空数组时，", 
				"可以使用Statement.sgetGeneratedKeys()获取由于执行此 Statement对象而创建的所有自动生成的键(可能执行多个insert sql)");
		PrintUtil.three("7.1：当参数指columnNames定为null或空数组", "则不能调用Statement.sgetGeneratedKeys()，否者会抛出异常：\n"
				+ "异常信息为：java.sql.SQLException: Generated keys not requested. You need to specify Statement.RETURN_GENERATED_KEYS to Statement.executeUpdate(), Statement.executeLargeUpdate() or Connection.prepareStatement().");
		PrintUtil.three("7.2：由于可能执行多个insert sql：", "所以使用ResultSet作为接受自动生成主键的集合，通过循环获取每个执行结果的主键，获取索引从1开始");
		PrintUtil.three("7.3：如果表主键没有设置为自增主键的情况下", "是要在insert 指定每条数据的主键ID，且不重复，故不需要通过Statement.sgetGeneratedKeys()再次获取主键，当然获取的主键的集合也insert 数据记录的集合主键一致");
		PrintUtil.three("7.4：通过ResultSet.getXXX(1)获取主键", "注意要和表主键的数据类型映射到java数据一致");
		if(generatedKeys != null) {
			while (generatedKeys.next()) {
				PrintUtil.three("7.5.通过循环获取到的执行结果后的主键ID", "bookId="+generatedKeys.getLong(1));
			}
		}
	}

	/**
	 * @description 测试新增SQL
	 * @author mutisitic
	 * @date 2018年9月26日
	 * @param bookId 主键ID
	 * @return
	 */
	private static String testSQL(Long bookId) {
		return "INSERT INTO `book` (`bookId`, `title`, `author`, `remark`, `createrTime`) VALUES (" + bookId
				+ "," + "'test by jdbc', 'test author', '使用Statement.execute接口实现数据新增', '" + CommonUtil.getCurrentTime() + "')";
	}
}
