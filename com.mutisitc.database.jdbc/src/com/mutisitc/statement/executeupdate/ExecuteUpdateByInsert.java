package com.mutisitc.statement.executeupdate;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import com.mutisitc.utils.CommonUtil;
import com.mutisitc.utils.PrintUtil;

/**
 * @program 使用Statement.executeUpdate接口实现数据新增
 * @description
 * @author mutisitic
 * @date 2018年9月26日
 */
public class ExecuteUpdateByInsert {
	/**
	 * @description 使用Statement.executeUpdate接口实现数据新增
	 * @author mutisitic
	 * @date 2018年9月26日
	 * @param statement
	 * @throws SQLException
	 */
	public static void mainByInsert(Statement statement) throws SQLException {
		mianByExecute(statement);
		mianByAutoGeneratedKeys(statement);
		mainByColumnIndexes(statement);
		mainByColumnNames(statement);
		
		PrintUtil.two("五、根据mysql-connector-java-8.0.11.jar源码分析：", "executeUpdate方法底层还是调用executeLargeUpdate方法");
		PrintUtil.three("5.1、com.mysql.cj.jdbc.StatementImpl：方法具体代码：", null);
		PrintUtil.two("public int executeUpdate(String sql) throws SQLException {\r\n" + 
				"    return Util.truncateAndConvertToInt(executeLargeUpdate(sql));\r\n" + 
				"}\r\n"+ 
				"\r\n" + 
				"public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {\r\n" + 
				"    return Util.truncateAndConvertToInt(executeLargeUpdate(sql, autoGeneratedKeys));\r\n" + 
				"}\r\n" + 
				"\r\n" + 
				"public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {\r\n" + 
				"    return Util.truncateAndConvertToInt(executeLargeUpdate(sql, columnIndexes));\r\n" + 
				"}\r\n" + 
				"\r\n" + 
				"public int executeUpdate(String sql, String[] columnNames) throws SQLException {\r\n" + 
				"    return Util.truncateAndConvertToInt(executeLargeUpdate(sql, columnNames));\r\n" + 
				"}", null);
		
		PrintUtil.two("\n六、方法参数autoGeneratedKeys、columnIndexes、columnNames", "用法和execute()方法的用法一致");
	}

	/**
	 * @description 使用 Statement.executeUpdate(String sql)：数据新增
	 * @author mutisitic
	 * @date 2018年9月26日
	 * @param statement
	 * @throws SQLException
	 */
	private static void mianByExecute(Statement statement) throws SQLException {
		PrintUtil.one("一、使用 Statement.executeUpdate(String sql)：数据新增：");
		
		String insertSQL = testSQL(System.currentTimeMillis());
		PrintUtil.two("3.数据新增SQL语句：", insertSQL);

		int executeUpdateResult = statement.executeUpdate(insertSQL);
		PrintUtil.two("4.Statement.executeUpdate(String sql)：数据新增执行结果", "executeUpdateResult=" + executeUpdateResult);
		PrintUtil.three("4.1：具体描述:", "执行给定的SQL语句，它可以是一个INSERT， UPDATE或者DELETE语句，或者不返回任何内容的SQL语句(如SQL DDL语句)");
		PrintUtil.three("4.2：方法返回结果：", "SQL数据操作语言（DML）语句的行数 或 0表示不返回任何内容的SQL语句");
	}
	
	/**
	 * @description 使用  Statement.executeUpdate(String sql, int autoGeneratedKeys)：数据新增
	 * @author mutisitic
	 * @date 2018年9月26日
	 * @param statement
	 * @throws SQLException
	 */
	private static void mianByAutoGeneratedKeys(Statement statement) throws SQLException {
		PrintUtil.one("二、使用  Statement.executeUpdate(String sql, int autoGeneratedKeys)：数据新增：");
		
		String insertSQL = testSQL(null);
		PrintUtil.two("3.数据新增SQL语句：", insertSQL);

		int executeUpdateResult = statement.executeUpdate(insertSQL, Statement.RETURN_GENERATED_KEYS);
		PrintUtil.two("4.Statement.executeUpdate(String sql, int autoGeneratedKeys)：数据新增执行结果", "executeUpdateResult=" + executeUpdateResult);
		PrintUtil.three("4.1：具体描述:", "执行给定的SQL语句，它可以是一个INSERT， UPDATE或者DELETE语句，或者不返回任何内容的SQL语句(如SQL DDL语句)");
		PrintUtil.three("4.2：方法返回结果：", "SQL数据操作语言（DML）语句的行数 或 0表示不返回任何内容的SQL语句");

		ResultSet generatedKeys = statement.getGeneratedKeys();
		PrintUtil.two("5.当指定参数autoGeneratedKeys时，且autoGeneratedKeys=Statement.RETURN_GENERATED_KEYS"+Statement.RETURN_GENERATED_KEYS, 
				"可以使用Statement.sgetGeneratedKeys()获取由于执行此 Statement对象而创建的所有自动生成的键(可能执行多个insert sql)");
		PrintUtil.three("5.1：当参数指autoGeneratedKeys定为Statement.NO_GENERATED_KEYS或不为Statement.RETURN_GENERATED_KEYS的其他值",
				"则不能调用Statement.sgetGeneratedKeys()，否者会抛出异常：\n"
				+ "异常信息为：java.sql.SQLException: Generated keys not requested. You need to specify Statement.RETURN_GENERATED_KEYS to Statement.executeUpdateUpdate(), Statement.executeUpdateLargeUpdate() or Connection.prepareStatement().");
		PrintUtil.three("5.2：由于可能执行多个insert sql：", "所以使用ResultSet作为接受自动生成主键的集合，通过循环获取每个执行结果的主键，获取索引从1开始");
		PrintUtil.three("5.3：如果表主键没有设置为自增主键的情况下", "是要在insert 指定每条数据的主键ID，且不重复，故不需要通过Statement.sgetGeneratedKeys()再次获取主键，当然获取的主键的集合也insert 数据记录的集合主键一致");
		PrintUtil.three("5.4：通过ResultSet.getXXX(1)获取主键", "注意要和表主键的数据类型映射到java数据一致");
		if(generatedKeys != null) {
			while (generatedKeys.next()) {
				PrintUtil.three("5.5.通过循环获取到的执行结果后的主键ID", "bookId="+generatedKeys.getLong(1));
			}
		}
	}
	
	/**
	 * @description 使用  Statement.executeUpdate(String sql, int[] columnIndexes)：数据新增
	 * @author mutisitic
	 * @date 2018年9月26日
	 * @param statement
	 * @throws SQLException 
	 */
	private static void mainByColumnIndexes(Statement statement) throws SQLException {
		PrintUtil.one("三、使用  Statement.executeUpdate(String sql, int[] columnIndexes)：数据新增：");
		
		String insertSQL = testSQL(null);
		PrintUtil.two("3.数据新增SQL语句：", insertSQL);

		int[] columnIndexes = new int[] {0};
		int executeUpdateResult = statement.executeUpdate(insertSQL, columnIndexes);
		PrintUtil.two("4.Statement.executeUpdate(String sql, int[] columnIndexes)：数据新增执行结果", "executeUpdateResult=" + executeUpdateResult+", columnIndexes="+ CommonUtil.toString(columnIndexes));
		PrintUtil.three("4.1：具体描述:", "执行给定的SQL语句，它可以是一个INSERT， UPDATE或者DELETE语句，或者不返回任何内容的SQL语句(如SQL DDL语句)");
		PrintUtil.three("4.2：方法返回结果：", "SQL数据操作语言（DML）语句的行数 或 0表示不返回任何内容的SQL语句");

		ResultSet generatedKeys = statement.getGeneratedKeys();
		PrintUtil.two("5.当指定参数columnIndexes时，且columnIndexes不为null且空数组时，", 
				"可以使用Statement.sgetGeneratedKeys()获取由于执行此 Statement对象而创建的所有自动生成的键(可能执行多个insert sql)");
		PrintUtil.three("5.1：当参数指columnIndexes定为null或空数组", "则不能调用Statement.sgetGeneratedKeys()，否者会抛出异常：\n"
				+ "异常信息为：java.sql.SQLException: Generated keys not requested. You need to specify Statement.RETURN_GENERATED_KEYS to Statement.executeUpdateUpdate(), Statement.executeUpdateLargeUpdate() or Connection.prepareStatement().");
		PrintUtil.three("5.2：由于可能执行多个insert sql：", "所以使用ResultSet作为接受自动生成主键的集合，通过循环获取每个执行结果的主键，获取索引从1开始");
		PrintUtil.three("5.3：如果表主键没有设置为自增主键的情况下", "是要在insert 指定每条数据的主键ID，且不重复，故不需要通过Statement.sgetGeneratedKeys()再次获取主键，当然获取的主键的集合也insert 数据记录的集合主键一致");
		PrintUtil.three("5.4：通过ResultSet.getXXX(1)获取主键", "注意要和表主键的数据类型映射到java数据一致");
		if(generatedKeys != null) {
			while (generatedKeys.next()) {
				PrintUtil.three("5.5.通过循环获取到的执行结果后的主键ID", "bookId="+generatedKeys.getLong(1));
			}
		}
	}
	
	/**
	 * @description 使用  Statement.executeUpdate(String sql, String[] columnNames)：数据新增
	 * @author mutisitic
	 * @date 2018年9月26日
	 * @param statement
	 * @throws SQLException 
	 */
	private static void mainByColumnNames(Statement statement) throws SQLException {
		PrintUtil.one("四、使用  Statement.executeUpdate(String sql, String[] columnNames)：数据新增：");
		
		String insertSQL = testSQL(null);
		PrintUtil.two("3.数据新增SQL语句：", insertSQL);

		String[] columnNames = new String[] {"bookId"};
		int executeUpdateResult = statement.executeUpdate(insertSQL, columnNames);
		PrintUtil.two("4.Statement.executeUpdate(String sql, int[] columnIndexes)：数据新增执行结果", "executeUpdateResult=" + executeUpdateResult+", columnNames="+ CommonUtil.toString(columnNames));
		PrintUtil.three("4.1：具体描述:", "执行给定的SQL语句，它可以是一个INSERT， UPDATE或者DELETE语句，或者不返回任何内容的SQL语句(如SQL DDL语句)");
		PrintUtil.three("4.2：方法返回结果：", "SQL数据操作语言（DML）语句的行数 或 0表示不返回任何内容的SQL语句");
		
		ResultSet generatedKeys = statement.getGeneratedKeys();
		PrintUtil.two("5.当指定参数columnNames时，且columnNames不为null且空数组时，", 
				"可以使用Statement.sgetGeneratedKeys()获取由于执行此 Statement对象而创建的所有自动生成的键(可能执行多个insert sql)");
		PrintUtil.three("5.1：当参数指columnNames定为null或空数组", "则不能调用Statement.sgetGeneratedKeys()，否者会抛出异常：\n"
				+ "异常信息为：java.sql.SQLException: Generated keys not requested. You need to specify Statement.RETURN_GENERATED_KEYS to Statement.executeUpdateUpdate(), Statement.executeUpdateLargeUpdate() or Connection.prepareStatement().");
		PrintUtil.three("5.2：由于可能执行多个insert sql：", "所以使用ResultSet作为接受自动生成主键的集合，通过循环获取每个执行结果的主键，获取索引从1开始");
		PrintUtil.three("5.3：如果表主键没有设置为自增主键的情况下", "是要在insert 指定每条数据的主键ID，且不重复，故不需要通过Statement.sgetGeneratedKeys()再次获取主键，当然获取的主键的集合也insert 数据记录的集合主键一致");
		PrintUtil.three("5.4：通过ResultSet.getXXX(1)获取主键", "注意要和表主键的数据类型映射到java数据一致");
		if(generatedKeys != null) {
			while (generatedKeys.next()) {
				PrintUtil.three("5.5.通过循环获取到的执行结果后的主键ID", "bookId="+generatedKeys.getLong(1));
			}
		}
	}

	/**
	 * @description 测试新增SQL
	 * @author mutisitic
	 * @date 2018年9月26日
	 * @param bookId 主键ID
	 * @return
	 */
	private static String testSQL(Long bookId) {
		return "INSERT INTO `book` (`bookId`, `title`, `author`, `remark`, `createrTime`) VALUES (" + bookId
				+ "," + "'test by jdbc', 'test author', '使用Statement.executeUpdate接口实现数据新增', '" + CommonUtil.getCurrentTime() + "')";
	}
}
