package com.mutisitc.statement.executeupdate;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import com.mutisitc.utils.CommonUtil;
import com.mutisitc.utils.JDBCUtil;
import com.mutisitc.utils.PrintUtil;

/**
 * @program 使用Statement.executeUpdate接口实现插入数据
 * @description
 * @author mutisitic
 * @date 2018年9月25日
 */
public class InsertByExecuteUpdateMain {
	public static void main(String[] args) {
		PrintUtil.one("使用Statement.executeUpdate接口实现插入数据：");
		try {
			Statement statement = JDBCUtil.createStatement();

			mianByExecuteUpdate(statement);
			mianByAutoGeneratedKeys(statement);
			mainByColumnIndexes(statement);
			mainByColumnNames(statement);
			
			JDBCUtil.close(statement);
		} catch (SQLException e) {
			PrintUtil.err("使用Statement.executeUpdate接口实现插入数据，打印异常堆栈信息：");
			e.printStackTrace();
		}
	}

	/**
	 * @description 使用 Statement.execute(String sql)：插入数据
	 * @author mutisitic
	 * @date 2018年9月25日
	 * @param statement
	 * @throws SQLException
	 */
	private static void mianByExecuteUpdate(Statement statement) throws SQLException {
		PrintUtil.one("一、使用 Statement.executeUpdate(String sql)：插入数据：");
		String insertSQL = "INSERT INTO `book` (`bookId`, `title`, `author`, `remark`, `createrTime`) VALUES ("
			+ System.currentTimeMillis() + ", 'test by jdbc', 'test author', 'test remark', '"+ CommonUtil.getCurrentTime() + "')";

		PrintUtil.two("3.插入数据SQL语句：", insertSQL);

		int executeUpdateResult = statement.executeUpdate(insertSQL);
		PrintUtil.two("4.Statement.executeUpdate(String sql)：插入数据执行结果", "executeUpdateResult=" + executeUpdateResult);
		PrintUtil.three("4.1：具体描述:", "执行给定的SQL语句，它可以是一个INSERT， UPDATE或者DELETE语句，或者不返回任何内容，如SQL DDL语句的SQL语句");
		PrintUtil.three("4.3：方法返回结果：", "SQL数据操作语言（DML）语句的行数 或 0表示不返回任何内容的SQL语句");

		PrintUtil.two("5.使用Statement.getResultSet()获取执行SQL后的结果", "java.sql.ResultSet=" + statement.getResultSet());
		PrintUtil.two("6.使用Statement.getUpdateCount()获取执行SQL后的结果", "updateCount=" + statement.getUpdateCount());
	}
	
	/**
	 * @description 使用  Statement.execute(String sql, int autoGeneratedKeys)：插入数据
	 * @author mutisitic
	 * @date 2018年9月25日
	 * @param statement
	 * @throws SQLException
	 */
	private static void mianByAutoGeneratedKeys(Statement statement) throws SQLException {
		PrintUtil.one("二、使用  Statement.executeUpdate(String sql, int autoGeneratedKeys)：插入数据：");
		String insertSQL = "INSERT INTO `book` (`bookId`, `title`, `author`, `remark`, `createrTime`) VALUES (" + null
				+ "," + "'test by jdbc', 'test author', 'test remark', '" + CommonUtil.getCurrentTime() + "')";

		PrintUtil.two("3.插入数据SQL语句：", insertSQL);

		int executeUpdateResult = statement.executeUpdate(insertSQL, Statement.RETURN_GENERATED_KEYS);
		PrintUtil.two("4.Statement.executeUpdate(String sql, int autoGeneratedKeys)：插入数据执行结果", "executeUpdateResult=" + executeUpdateResult);
		PrintUtil.three("4.1：具体描述:", "执行给定的SQL语句，它可以是一个INSERT， UPDATE或者DELETE语句，或者不返回任何内容，如SQL DDL语句的SQL语句");
		PrintUtil.three("4.2：参数描述：autoGeneratedKeys", "指示是否应该使用 getGeneratedKeys 方法使自动生成的键可用于获取的常量；"
				+ "  \n 以下常量之一：Statement.RETURN_GENERATED_KEYS 或 Statement.NO_GENERATED_KEYS ");
		PrintUtil.three("4.3：方法返回结果：", "SQL数据操作语言（DML）语句的行数 或 0表示不返回任何内容的SQL语句");

		PrintUtil.two("5.使用Statement.getResultSet()获取执行SQL后的结果", "java.sql.ResultSet=" + statement.getResultSet());
		PrintUtil.two("6.使用Statement.getUpdateCount()获取执行SQL后的结果", "updateCount=" + statement.getUpdateCount());
		
		ResultSet generatedKeys = statement.getGeneratedKeys();
		PrintUtil.two("7.当指定参数autoGeneratedKeys时，且autoGeneratedKeys=Statement.RETURN_GENERATED_KEYS"+Statement.RETURN_GENERATED_KEYS, 
				"可以使用Statement.sgetGeneratedKeys()获取由于执行此 Statement对象而创建的所有自动生成的键(可能执行多个insert sql)");
		PrintUtil.three("7.1：当参数指autoGeneratedKeys定为Statement.NO_GENERATED_KEYS或不为Statement.RETURN_GENERATED_KEYS的其他值",
				"则不能调用Statement.sgetGeneratedKeys()，否者会抛出异常：\n"
				+ "异常信息为：java.sql.SQLException: Generated keys not requested. You need to specify Statement.RETURN_GENERATED_KEYS to Statement.executeUpdate(), Statement.executeLargeUpdate() or Connection.prepareStatement().");
		PrintUtil.three("7.2：由于可能执行多个insert sql：", "所以使用ResultSet作为接受自动生成主键的集合，通过循环获取每个执行结果的主键，获取索引从1开始");
		PrintUtil.three("7.3：如果表主键没有设置为自增主键的情况下", "是要在insert 指定每条数据的主键ID，且不重复，故不需要通过Statement.sgetGeneratedKeys()再次获取主键，当然获取的主键的集合也insert 数据记录的集合主键一致");
		PrintUtil.three("7.4：通过ResultSet.getXXX(1)获取主键", "注意要和表主键的数据类型映射到java数据一致");
		if(generatedKeys != null) {
			while (generatedKeys.next()) {
				PrintUtil.three("7.5.通过循环获取到的执行结果后的主键ID", "bookId="+generatedKeys.getLong(1));
			}
		}
	}
	
	/**
	 * @description 使用  Statement.execute(String sql, int[] columnIndexes)：插入数据
	 * @author mutisitic
	 * @date 2018年9月25日
	 * @param statement
	 * @throws SQLException 
	 */
	private static void mainByColumnIndexes(Statement statement) throws SQLException {
		PrintUtil.one("三、使用  Statement.executeUpdate(String sql, int[] columnIndexes)：插入数据：");
		String insertSQL = "INSERT INTO `book` (`bookId`, `title`, `author`, `remark`, `createrTime`) VALUES (" + null
				+ "," + "'test by jdbc', 'test author', 'test remark', '" + CommonUtil.getCurrentTime() + "')";

		PrintUtil.two("3.插入数据SQL语句：", insertSQL);

		int[] columnIndexes = new int[] {0};
		int executeUpdateResult = statement.executeUpdate(insertSQL, columnIndexes);
		PrintUtil.two("4.Statement.executeUpdate(String sql, int[] columnIndexes)：插入数据执行结果", "executeUpdateResult=" + executeUpdateResult+", columnIndexes="+ CommonUtil.toString(columnIndexes));
		PrintUtil.three("4.1：具体描述:", "执行给定的SQL语句，它可以是一个INSERT， UPDATE或者DELETE语句，或者不返回任何内容，如SQL DDL语句的SQL语句");
		PrintUtil.three("4.2：参数描述：columnIndexes", "通过调用方法 getGeneratedKeys 应该可用于获取的插入行中的列索引数组");
		PrintUtil.three("4.3：方法返回结果：", "SQL数据操作语言（DML）语句的行数 或 0表示不返回任何内容的SQL语句");

		PrintUtil.two("5.使用Statement.getResultSet()获取执行SQL后的结果", "java.sql.ResultSet=" + statement.getResultSet());
		PrintUtil.two("6.使用Statement.getUpdateCount()获取执行SQL后的结果", "updateCount=" + statement.getUpdateCount());
		
		ResultSet generatedKeys = statement.getGeneratedKeys();
		PrintUtil.two("7.当指定参数columnIndexes时，且columnIndexes不为null且空数组时，", 
				"可以使用Statement.sgetGeneratedKeys()获取由于执行此 Statement对象而创建的所有自动生成的键(可能执行多个insert sql)");
		PrintUtil.three("7.1：当参数指columnIndexes定为null或空数组", "则不能调用Statement.sgetGeneratedKeys()，否者会抛出异常：\n"
				+ "异常信息为：java.sql.SQLException: Generated keys not requested. You need to specify Statement.RETURN_GENERATED_KEYS to Statement.executeUpdate(), Statement.executeLargeUpdate() or Connection.prepareStatement().");
		PrintUtil.three("7.2：由于可能执行多个insert sql：", "所以使用ResultSet作为接受自动生成主键的集合，通过循环获取每个执行结果的主键，获取索引从1开始");
		PrintUtil.three("7.3：如果表主键没有设置为自增主键的情况下", "是要在insert 指定每条数据的主键ID，且不重复，故不需要通过Statement.sgetGeneratedKeys()再次获取主键，当然获取的主键的集合也insert 数据记录的集合主键一致");
		PrintUtil.three("7.4：通过ResultSet.getXXX(1)获取主键", "注意要和表主键的数据类型映射到java数据一致");
		if(generatedKeys != null) {
			while (generatedKeys.next()) {
				PrintUtil.three("7.5.通过循环获取到的执行结果后的主键ID", "bookId="+generatedKeys.getLong(1));
			}
		}
	}
	
	/**
	 * @description 使用  Statement.execute(String sql, String[] columnNames)：插入数据
	 * @author mutisitic
	 * @date 2018年9月25日
	 * @param statement
	 * @throws SQLException 
	 */
	private static void mainByColumnNames(Statement statement) throws SQLException {
		PrintUtil.one("四、使用  Statement.executeUpdate(String sql, String[] columnNames)：插入数据：");
		String insertSQL = "INSERT INTO `book` (`bookId`, `title`, `author`, `remark`, `createrTime`) VALUES (" + null
				+ "," + "'test by jdbc', 'test author', 'test remark', '" + CommonUtil.getCurrentTime() + "')";

		PrintUtil.two("3.插入数据SQL语句：", insertSQL);

		String[] columnNames = new String[] {"bookId"};
		int executeUpdateResult = statement.executeUpdate(insertSQL, columnNames);
		PrintUtil.two("4.Statement.executeUpdate(String sql, int[] columnIndexes)：插入数据执行结果", "executeUpdateResult=" + executeUpdateResult+", columnNames="+ CommonUtil.toString(columnNames));
		PrintUtil.three("4.1：具体描述:", "执行给定的SQL语句，它可以是一个INSERT， UPDATE或者DELETE语句，或者不返回任何内容，如SQL DDL语句的SQL语句");
		PrintUtil.three("4.2：参数描述：columnNames", "通过调用方法 getGeneratedKeys 应该可用于获取的插入行中的列名称数组");
		PrintUtil.three("4.3：方法返回结果：", "SQL数据操作语言（DML）语句的行数 或 0表示不返回任何内容的SQL语句");

		PrintUtil.two("5.使用Statement.getResultSet()获取执行SQL后的结果", "java.sql.ResultSet=" + statement.getResultSet());
		PrintUtil.two("6.使用Statement.getUpdateCount()获取执行SQL后的结果", "updateCount=" + statement.getUpdateCount());
		
		ResultSet generatedKeys = statement.getGeneratedKeys();
		PrintUtil.two("7.当指定参数columnNames时，且columnNames不为null且空数组时，", 
				"可以使用Statement.sgetGeneratedKeys()获取由于执行此 Statement对象而创建的所有自动生成的键(可能执行多个insert sql)");
		PrintUtil.three("7.1：当参数指columnNames定为null或空数组", "则不能调用Statement.sgetGeneratedKeys()，否者会抛出异常：\n"
				+ "异常信息为：java.sql.SQLException: Generated keys not requested. You need to specify Statement.RETURN_GENERATED_KEYS to Statement.executeUpdate(), Statement.executeLargeUpdate() or Connection.prepareStatement().");
		PrintUtil.three("7.2：由于可能执行多个insert sql：", "所以使用ResultSet作为接受自动生成主键的集合，通过循环获取每个执行结果的主键，获取索引从1开始");
		PrintUtil.three("7.3：如果表主键没有设置为自增主键的情况下", "是要在insert 指定每条数据的主键ID，且不重复，故不需要通过Statement.sgetGeneratedKeys()再次获取主键，当然获取的主键的集合也insert 数据记录的集合主键一致");
		PrintUtil.three("7.4：通过ResultSet.getXXX(1)获取主键", "注意要和表主键的数据类型映射到java数据一致");
		if(generatedKeys != null) {
			while (generatedKeys.next()) {
				PrintUtil.three("7.5.通过循环获取到的执行结果后的主键ID", "bookId="+generatedKeys.getLong(1));
			}
		}
	}
}
